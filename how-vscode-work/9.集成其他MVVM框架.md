#### 一、其他工具是怎么做的

1、支付宝开发者工具
少有的可以打开登录窗口、项目窗口的调试器的工具。不好评

首先不管工作台主题如何变化, 项目窗口、登录窗口主题都是固定的。

#### 二、尝试添加 vite-vue 项目

1、通过理解 app.once('ready', function () {})
定义自己的窗口管理, vscode 只提供代码编辑功能, 虽然这是最主要的功能

2、根目录创建 vite-vue 项目
完善 README.md 文件
完善 vscode 脚本, 添加 vite-vue 项目依赖的步骤。并且启动 vscode 的时候要启动 vite-vue

npm run watch 或者 npm run compile 的时候, 也将 vite 项目进行打包
解决类型定义错误, 比如 App.vue

vscode 编译 preload 脚本

```shell
npm run gulp vscode-darwin-arm64 # 会生成out-vscode。 这个目录会是electron加载的。 但是没有preload2.js
```

需要解决
同时也会产生 out-build 目录, 这个里面就有 preload2.js
为什么

查看./build/gulpfile

将打包的 dist 搬到 out-vscode
打包的命令是

```shell
npm run gulp vscode-darwin-arm64
```

会知道 gulpfile.js, 并且运行 vscode-drawin-arm64 这个 task
查看 build/gulpfile.vscode.js。 这个文件会遍历系统架构, 分别定义不同的任务

```js
const BUILD_TARGETS = [
	{ platform: "win32", arch: "x64" },
	{ platform: "win32", arch: "arm64" },
	{ platform: "darwin", arch: "x64", opts: { stats: true } },
	{ platform: "darwin", arch: "arm64", opts: { stats: true } },
	{ platform: "linux", arch: "x64" },
	{ platform: "linux", arch: "armhf" },
	{ platform: "linux", arch: "arm64" },
];
BUILD_TARGETS.forEach((buildTarget) => {
	const dashed = (str) => (str ? `-${str}` : ``);
	const platform = buildTarget.platform;
	const arch = buildTarget.arch;
	const opts = buildTarget.opts;

	console.log("buildTarget: ", buildTarget);

	const [vscode, vscodeMin] = ["", "min"].map((minified) => {
		const sourceFolderName = `out-vscode${dashed(minified)}`;
		const destinationFolderName = `VSCode${dashed(platform)}${dashed(arch)}`;

		const tasks = [
			compileNativeExtensionsBuildTask,
			util.rimraf(path.join(buildRoot, destinationFolderName)),
			packageTask(
				platform,
				arch,
				sourceFolderName,
				destinationFolderName,
				opts
			),
		];

		if (platform === "win32") {
			tasks.push(patchWin32DependenciesTask(destinationFolderName));
		}

		const vscodeTaskCI = task.define(
			`vscode${dashed(platform)}${dashed(arch)}${dashed(minified)}-ci`,
			task.series(...tasks)
		);
		gulp.task(vscodeTaskCI);

		const vscodeTask = task.define(
			`vscode${dashed(platform)}${dashed(arch)}${dashed(minified)}`,
			task.series(
				minified
					? compileBuildWithManglingTask
					: compileBuildWithoutManglingTask,
				cleanExtensionsBuildTask,
				compileNonNativeExtensionsBuildTask,
				compileExtensionMediaBuildTask,
				minified ? minifyVSCodeTask : bundleVSCodeTask,
				vscodeTaskCI
			)
		);
		gulp.task(vscodeTask);

		return vscodeTask;
	});

	if (process.platform === platform && process.arch === arch) {
		gulp.task(task.define("vscode", task.series(vscode)));
		gulp.task(task.define("vscode-min", task.series(vscodeMin)));
	}
});
```

在这里做文章

3、添加这个项目需要的 UI 库
naive-ui

4、为窗口添加 preload.js

```js
const win = new BrowserWindow({
	width: 330,
	height: 470,
	webPreferences: {
		preload: FileAccess.asFileUri(
			"vs/base/parts/sandbox/electron-sandbox/preload.js"
		).fsPath,
		enableWebSQL: false,
		spellcheck: false,
		sandbox: true,
	},
});
win.loadURL("http://localhost:5173");
```

报错 Preload: did not find expected vscode-window-config in renderer process arguments list.

找到这个错误

```ts
function parseArgv(key: string): string | undefined {
	for (const arg of process.argv) {
		if (arg.indexOf(`--${key}=`) === 0) {
			return arg.split("=")[1];
		}
	}

	return undefined;
}
const windowConfigIpcChannel = parseArgv("vscode-window-config");
if (!windowConfigIpcChannel) {
	throw new Error(
		"Preload: did not find expected vscode-window-config in renderer process arguments list."
	);
}
```

一个类似的配置是 --vscode-window-config=vscode:88dccffe-8dee-4c68-b885-de46c4ea7450
经过 parseArgv 后会得到 vscode:88dccffe-8dee-4c68-b885-de46c4ea7450

但是我们从其他地方拿到的这个 配置直接使用会报错
Error: Preload: unable to fetch vscode-window-config: Error: Error invoking remote method 'vscode:88dccffe-8dee-4c68-b885-de46c4ea7450': Error: No handler registered for 'vscode:88dccffe-8dee-4c68-b885-de46c4ea7450'

问题就出现在 await ipcRenderer.invoke(windowConfigIpcChannel);
一定要有主进程注册了这个 windowConfigIpcChannel channel
invoke 的方法在主进程是通过 ipcMain.handle() 处理的

全文只有 src/vs/base/parts/ipc/electron-main/ipcMain.ts ValidatedIpcMain 这个类用到了

```ts
handle(channel: string, listener: (event: electron.IpcMainInvokeEvent, ...args: any[]) => Promise<unknown>): this {
	console.log('handle handle handle: ', channel);
	electron.ipcMain.handle(channel, (event: electron.IpcMainInvokeEvent, ...args: any[]) => {
		if (this.validateEvent(channel, event)) {
			return listener(event, ...args);
		}

		return Promise.reject(`Invalid channel '${channel}' or sender for ipcMain.handle() usage.`);
	});
	return this;
}
```

他导出一个实例

```ts
export const validatedIpcMain = new ValidatedIpcMain();
```

validatedIpcMain.handle
在 ProtocolMainService 这个类有使用到

```ts
createIPCObjectUrl<T>(): IIPCObjectUrl<T> {
	let obj: T | undefined = undefined;

	// Create unique URI
	const resource = URI.from({
		scheme: 'vscode', // used for all our IPC communication (vscode:<channel>)
		path: generateUuid()
	});

	// Install IPC handler
	const channel = resource.toString();
	const handler = async (): Promise<T | undefined> => obj;
	validatedIpcMain.handle(channel, handler);

	this.logService.trace(`IPC Object URL: Registered new channel ${channel}.`);

	return {
		resource,
		update: updatedObj => obj = updatedObj,
		dispose: () => {
			this.logService.trace(`IPC Object URL: Removed channel ${channel}.`);

			validatedIpcMain.removeHandler(channel);
		}
	};
}
```

#### 修改 workbench-dev.html

1、VSCode 的 CSP (Content Security Policy) 限制了可用的 TrustedTypePolicy。我们需要在 CSP 中添加 Vue 相关的 trusted-types。

```html
vue vue-loader vue-template-compiler
```

2、添加 vue 运行时脚本

```html
<!-- 添加了 Vite 客户端脚本，用于处理模块热重载等功能 -->
<script type="module" src="http://localhost:5173/@vite/client"></script>
<!-- 使用 Vite 的开发服务器地址，这样可以直接加载 TypeScript 文件 -->
<script type="module" src="http://localhost:5173/src/main.ts"></script>
```

修改vue
```typescript
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
import { createApp } from 'vue';
import './style.css';
import App from './App.vue';
import HeaderBar from './components/HeaderBar.vue';
import router from './router';
import './db';
import { createPinia } from 'pinia';
import { draggable } from './directives/draggable';

setTimeout(() => {
	const headerbarContainer = document.getElementById('headerbar-container');
	console.log('headerbarContainer: ', headerbarContainer);
	console.log('fuck you');
	const app = createApp(App);
	app.use(router);
	app.use(createPinia());
	app.directive('draggable', draggable);
	app.mount('#app');


	const header = createApp(HeaderBar);
	header.mount('#headerbar-container');
}, 3000);
```


